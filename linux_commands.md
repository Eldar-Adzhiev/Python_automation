# Назначение и каталоги

 - **/** - корень системы
 - **/etc** - конфигурация
 - **/home** - данные пользователя (управлять этой директорией сможет только сам пользователь) (когда заходим на удаленный сервер по ssh
  или когда только запустили компьютер то будем находиться в этой папке)
 - **/usr** - приложения (Папка, где находятся приложения если ставить стандартным способом)
 - **/var** - данные и каталоги (К примеру могут храниться логи в этой папке)
 - **/tmp** - временные файлы (Создает файлы в оперативной памяти)
 - **/boot** - ядро Линукса (Файлы которые отвечают за то как будет запускать Линукс из чего)
     (Ядро Линукса можно легко поменять просто перезаписав файлы)
 - **/dev** - девайсы (Отображаются подключенные девайсы мышка, флешка и т.д.)
 - **/run** - хранится инфо о всех запушенных процессах
 - **/opt** - аналог папки tools в windows
 - **/usr/bin** | **/usr/sbin** - дефолтные директории где хранятся исполняемые файлы

***В линуксе все файл!!!***

***

# Права доступа

- Владелец и группа
- Доступы по 8ричной маске
- chmod
- chown


|     | Owner | Group | Other Users |
|:---:|:-----:|:-----:|:-----------:|
|  - or d   | r w x | r w x |    r w x    |
|        | 4 2 1 | 4 2 1 |    4 2 1    |
|        |   7   |   7   |      7      |

- **-** : regular file
- **d** : directory
- **s** : local socket file
- **p** : named pipe
- **l** : symbolic link


- **r** - чтение (при установке прав имеет цифру 4)
- **w** - запись (при установке прав имеет цифру 2)
- **x** - выполнение (при установке прав имеет цифру 1)

Если хотим изменить права используем цифры с командой cmod

**Команда *sudo* временно повышает привилегии, позволяя пользователям выполнять конфиденциальные задачи без входа в систему как пользователь root.**
- **root** - Супер Пользователь
 

> Сменить пользователя:
>> chown ИмяПользователя:ИмяГруппы ИмяФайла

>Изменить права:
>> cmod 664 ИмяФайла

***

# Стандартные потоки

- **stdout(1)** - $ls - выведет папки
- **stdin(0)**  - $echo 'hello world' - Команда "echo" принимает строчку 'hello world' и выводит ее на экран
- **stderr(2)**  - $rm example.txt - No such file or directory

***

# Управление потоками

- **>** - вывод stdout в файл
- **>&** - вывод stdout и stderr в файл
- **2>** - вывод stderr в файл

***

# Pipes

- **|** - Можно писать команды многострочники. 

Пример:
> cat text.txt | wc -l
> 
> cat - Читает файл и выводит его в терминал
> 
> wc - Программа которая помогает считать

Команда cat отдает в stdout строки, а команда принимает в stdin строки и благодаря "Pipes" мы можем комбинировать команды

С помощью "|" мы можем соединять сколько угодно команд.  

**Pipes помогает stdout одной программы передать в stdin другой программы**

> echo '123445' > file.txt - запишит текст в файл (Если будут данные в файле перезапишет их)

> echo '123445' >> file.txt - дописывает текст в файл (Если будут данные в файле не будет перезаписывать их)


***

# Linux Shell

```CMD
docker run -it centos:centos7 /bin/bash 
```
Запускает контейнер в интерактивном режиме (отсюда флаг -it), что 
позволяет вам взаимодействовать с /bin/bash контейнера. Это означает, 
что теперь у вас будет сеанс bash внутри контейнера, поэтому вы 
можете использовать ls, mkdir или выполнять любую команду bash 
внутри контейнера.

>Nginx ― это программное обеспечение с открытым исходным кодом, которое позволяет создавать веб-сервер. Также его используют как почтовый сервер или обратный прокси-сервер. Веб-сервер — это программное обеспечение, основная задача которого — обработка входящих и исходящих запросов на различных протоколах передачи данных.

>yum - пакетный менеджер в centos

***
Установка nginx

```CMD
yum install nginx
```

***
Перечислите имена файлов в каталоге вместе с разрешениями, датой, временем и размером.
```CMD
ll /etc/yum.repos.d/
```

***
Установка репозитория epel (основной репозиторий для centos и Fedora)
```CMD
yum install epel-release
yum install -y epel-release
```
-y - означает сразу отвечать yes

***
Очистка временной базы сохранившейся после неудачной установки
```CMD
yum clean all
```

***
Посмотреть где находится бинарник программы
```CMD
which nginx
```

***
Посмотреть где хранятся все файлы связаные с программой (в данном случае с nginx )
```CMD
whereis nginx
```
***
Запуск nginx
```CMD
nginx
```
***
Отправить запрос
```CMD
curl http://127.0.0.1:80
```
***
Посмотреть расширенную информацию о запросе
```CMD
curl -v http://127.0.0.1:80
```
***
Посмотреть список процессов в линуксе
```CMD
ps
```
> PID - Уникальный ID процесса
>
> TTY - информация о терминале из которого выполняется эта команда
> 
> TIME - Время выполнения команды
> 
> CMD - Команда

***
Посмотреть расширенную информацию процессов в линуксе
```CMD
ps au
```
> %CPU - Сколько процентов процессора забирает данный процесс
> 
> %MEM - Сколько памяти забирает данный процесс
> 
> VSZ - Сколько забронировал себе виртуальной памяти
> 
> START - Когда был начат процесс

***
Посмотреть процессы на всех юзерах
```CMD
ps aux
```

***
Посмотреть процессы в древовидной структуре
```CMD
ps auxf
```
***
Посмотреть в какой папке находимся
```CMD
pwd
```
***
Посмотреть список файлов 
```CMD
ls -la
```
***
Посмотреть список файлов в читаемом виде, в килобайтах 
```CMD
ls -lah
```
***
Чтобы посмотреть доступное пространство на всех примонтированных разделах и информацию о них:
```CMD
df
```

***
Чтобы создать папку:
```CMD
mrdir folder_name
```
***
Чтобы создать вложенные папки:
```CMD
mrdir -p folder_name1/folder_name2
```

***
Создать файл:
```CMD
touch file_name
```

***
Ввести текст в файл:
```CMD
echo text >> file_name
```
> echo  выводит текст а команда >> перенаправлет его в файл


***
Прочитать файл:
```CMD
cat file_name
```

***
Вывести первые строки сверху:
```CMD
head file_name
```
***
Вывести определенное колличество первых строк сверху:
```CMD
head -2 file_name
```
***
Вывести строки снизу:
```CMD
tail file_name
```
***
Вывести определенное колличество строк снизу:
```CMD
tail -2 file_name
```
***
Динамически смотреть за записью в файле:
```CMD
tail -f file_name
tailf file_name
```
***
Динамически смотреть за записью в файле:
```CMD
tail -f file_name
tailf file_name
```
***
Просмотр файла командой less:
```CMD
less file_name
```
> Можно после открытия перемещаться по файлу стречками
> 
> shift + G - Преместится в самый низ файла
> 
> G - переместится в верх файла
> 
> shift + F - включить динамический режим
> 
> ctrl + C - выйти из режима слежания
> 
> /text - будет искать "text" с текущего положения совпадения вниз
> 
> ?text - будет искать "text" с текущего положения совпадения вверх
> 
> q - выйти из программы less


***
Убить процесс:
```CMD
kill PID_of_process
``` 
> -9 - Программа не перехватывает сигнал. Пренудительное закрытие процесса
> 
> -15 - Дефолтный сигнал. Программа перехватывает сигнал. завершает свои проццесы и после этого убивается


***
Посмотреть последний код программы:
```CMD
echo $?
``` 
***
Убить все процессы nginx:
```CMD
ps axuwf I grep nginx I grep -v grep I awk '{print $23' | xargs kill -15
``` 


***

# Bash scripting

> Все bash скрипты должны заканчиваться на .sh

***
Создать фаил в vim:
```CMD
vim file_name.sh
``` 
> i - Начать редактировать в vim \
> esc - выйти из режима редактирования \
> :w - сохранить файл \
> :q - выйти из vim \
> :wq - сохранить и выйти \
>:q! - выйти без сохранения \
> 

***
Запустить скрипт:
```CMD
./file_name.sh
``` 


***
Запустить скрипт:
```CMD
./file_name.sh
``` 

>#!/usr/bin/env bash - Шинбанговская линия. Говорит файлу как запускать файл в данном случает через bash \
>#!/usr/bin/env python - говорит файлу запускать через python
> 

Обращение к переменным:
```CMD
$variable_name
``` 
> "${variable_name}" - Так нужно обращаться к переменной что бы учитывали все перенесы строк \
> $variable_name - без учета спец символов 

***
Заменить подстроку root на kirillov:
```CMD
"${variable_name/root/kirillov}"
``` 
***
Заменить все подстроки root на kirillov:
```CMD
"${variable_name//root/kirillov}"
``` 
***
Сделать все буквы заглавными :
```CMD
"${variable_name^^}"
``` 

***
Если переменной нет заменить ее :
```CMD
"${variable_name:-DEFAULT}"
``` 
***
### Циклы:

Циклы for 
```CMD
pids=$(ps axuwf | grep root | awk '{print $2}')
echo $pids

for pid in $pids; do
    echo "CURR PID: ${pid}"
done

``` 

